---
title: Import
description: Convert SQL to query builder objects
---

import TypeScriptAdmonition from './_ts_admonition.md';

<TypeScriptAdmonition />

Use the `parseSQL` function to convert SQL `SELECT` statements into a format suitable for the `<QueryBuilder />` component's `query` prop. The function signature is:

```ts
function parseSQL(sql: string, options?: ParseSQLOptions): RuleGroupTypeAny;
```

`parseSQL` takes a SQL `SELECT` statement (either the full statement or the `WHERE` clause by itself). Try it out in the [demo](https://react-querybuilder.js.org/react-querybuilder/) by clicking the "Load from SQL" button.

The optional second parameter to `parseSQL` is an options object that configures how the function handles named or anonymous bind variables within the SQL string.

## Basic usage

Running any of the following statements will produce the same result (see below):

```ts
parseSQL(`SELECT * FROM t WHERE firstName = 'Steve' AND lastName = 'Vai'`);

parseSQL(`SELECT * FROM t WHERE firstName = ? AND lastName = ?`, {
  params: ['Steve', 'Vai'],
});

parseSQL(`SELECT * FROM t WHERE firstName = :p1 AND lastName = :p2`, {
  params: { p1: 'Steve', p2: 'Vai' },
});

parseSQL(`SELECT * FROM t WHERE firstName = $p1 AND lastName = $p2`, {
  params: { p1: 'Steve', p2: 'Vai' },
  paramPrefix: '$',
});
```

Output (`RuleGroupType`):

```ts
{
  combinator: "and",
  rules: [
    {
      field: "firstName",
      operator: "=",
      value: "Steve"
    },
    {
      field: "lastName",
      operator: "=",
      value: "Vai"
    }
  ]
}
```

### Lists as arrays

To generate actual arrays instead of comma-separated strings for lists of values following `IN` and `BETWEEN` operators, use the `listsAsArrays` option.

```ts
parseSQL(`SELECT * FROM t WHERE lastName IN ('Vai', 'Vaughan') AND age BETWEEN 20 AND 100`, {
  listsAsArrays: true;
});
```

Output:

```ts
{
  combinator: "and",
  rules: [
    {
      field: "lastName",
      operator: "in",
      value: ["Vai", "Vaughan"]
    },
    {
      field: "age",
      operator: "between",
      value: [20, 100]
    }
  ]
}
```

## Independent combinators

When the `independentCombinators` option is `true`, `parseSQL` will output a query with combinator identifiers between sibling rules/groups.

```ts
parseSQL(`SELECT * FROM t WHERE firstName = 'Steve' AND lastName = 'Vai'`, {
  independentCombinators: true,
});
```

Output (`RuleGroupTypeIC`):

```ts
{
  rules: [
    {
      field: 'firstName',
      operator: '=',
      value: 'Steve',
    },
    'and',
    {
      field: 'lastName',
      operator: '=',
      value: 'Vai',
    },
  ];
}
```

## Fields as value source

When the `fields` option (which accepts the same types as the [`fields` prop](./querybuilder#fields)) is provided, and _only_ if it is provided, then `parseSQL` will validate clauses that have a field identifier to the right of the operator instead of a primitive value. A `getValueSources` function can also be provided to help validate rules.

In order for such a rule to be considered valid, either the `getValueSources` return value, the field's `valueSources` property return value, or the field's `valueSources` property itself must be an array that includes the string "field".

```ts
parseSQL(`SELECT * FROM t WHERE firstName = lastName`, {
  fields: [
    { name: 'firstName', label: 'First Name' },
    { name: 'lastName', label: 'Last Name' },
  ],
  getValueSources: () => ['value', 'field'],
});
```

Output:

```ts
{
  combinator: "and",
  rules: [
    {
      field: "firstName",
      operator: "=",
      value: "lastName",
      valueSource: "field",
    },
  ],
}
```

:::note

`parseSQL` will only validate clauses where "field" is the _only_ value source. Operators that take multiple values, like "between" and "in", must only have field names to the right of the operator, not a mix of field names and primitive values.

:::
